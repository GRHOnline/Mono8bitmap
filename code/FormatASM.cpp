#include "FormatASM.h"

#define ASCII_LOWA 97
#define ASCII_LOWF 102
#define ASCII_FSLASH 47
#define ASCII_G 71

int ConvertToDecimal(int iHexHigh, int iHexLow)
{
    int iHigh = 0;
    int iLow = 0;

    //check for lower-case letter and CAPITALISE!
    if ( iHexHigh >= ASCII_LOWA && iHexHigh <= ASCII_LOWF)
    {
        iHexHigh -= 32;
    }

    if ( iHexLow >= ASCII_LOWA && iHexLow <= ASCII_LOWF)
    {
        iHexLow -= 32;
    }

    // reduce the ASCII value to an actual number first!
    if ( iHexHigh > ASCII_FSLASH && iHexHigh < ASCII_G)
    {
        iHigh = iHexHigh - 48;
        if ( iHigh > 9 ) iHigh = (iHexHigh - 64) + 9;
        iHigh = iHigh * 16;
    }


    if ( iHexLow > ASCII_FSLASH && iHexLow < ASCII_G)
    {
        iLow = iHexLow - 48;
        if ( iLow > 9 ) iLow = (iHexLow - 64) + 9;
    }

    return iHigh + iLow;
}

int LoadDecAssemblerData(const char * sInput, unsigned char * cPassback, int iLimit)
{

    FILE * FRead;
    bool bWrite = false;
    bool bSkip = false;
    int iValue = 0;
    int iCondition = 0;
    int iFound = 0;
    int iFirst, iSecond, iThird, iCombo;
    int iTrack = 0;

    FRead = fopen( sInput,"r");

    if (FRead == NULL)
    {
        fclose(FRead);
        return 666;
    }
    else
    {
        while ( iCondition == 0 )
        {
            iValue = getc(FRead);
            iCondition = feof(FRead);
//----------------------------------------------------------------------------------
            if ( iValue == ';' )
            {
                bSkip = true;
            }

            if ( iValue == 10 ) // should be end of line, this might be different depending on how the text file was generated!
            {
                bSkip=false;
            }

            if ( iValue >= '0' && iValue <= '9')
            {
                iTrack++;
                iValue -= 48; //Change from ASCII

                if ( iTrack == 1 )
                {
                    iFirst = iValue;
                    bWrite = false;
                }

                if ( iTrack == 2 )
                {
                    iSecond = iValue;
                    bWrite = false;
                }

                if ( iTrack == 3 )
                {
                    iThird = iValue;
                    //iTrack = 0;
                    //iCombo = (iFirst * 100)+ (iSecond * 10) + iThird;
                    bWrite = false;
                }
            }
            else
            {
                //They could be one,two or three chars!
                if ( iValue == ',' || iValue == 10 )
                {
                    if ( iTrack == 3) iCombo = (iFirst * 100)+ (iSecond * 10) + iThird;
                    if ( iTrack == 2) iCombo = (iFirst * 10) + iSecond;
                    if ( iTrack == 1) iCombo = iFirst;
                    if ( iTrack > 0 && iTrack < 4 ) bWrite = true;
                    iTrack = 0;
                }
                else
                {
                iTrack = 0;
                bWrite = false;
                }
            }
//---------------------------------------------------------------------------------
            if ( iFound < iLimit && iCondition == 0)
            {
                if ( bWrite == true && bSkip == false )
                {
                    *(cPassback + iFound) = iCombo ;
                    iFound++;
                    bWrite = false;
                    iTrack = 0;
                }

            }
        }


            fclose(FRead);
    }

    return 0;
}


int SaveDecAssemblerData(const char * sOutput, unsigned char * cPassback, int iLimit)
{

    FILE * F_Write;

    int iCondition = 0;
    int iFound = 0;
    int iEight = 8;

    F_Write = fopen( sOutput,"w"); // do we need to use wb to indicate binary not text mode?

    if (F_Write == NULL)
    {
        //fclose(F_Write);
        return 666;
    }
    else
    {
        fputs("; Assembly language data in Decimal. \n", F_Write);
        fputs("; Generated by Mono8bitmap \n", F_Write);
        while ( iCondition == 0 )
        {

            if ( iFound < iLimit )
            {
                if ( iEight == 8 ) fputs(".byte ", F_Write);
                //fputc ( *(cPassback + iFound) , F_Write );
                fprintf( F_Write, "%u", *(cPassback + iFound));
                iFound++;
                if ( iEight <= 8 && iEight > 1 ) fputc(',', F_Write);
                iEight--;
                if ( iEight < 1)
                {
                    iEight = 8;
                    fputs("\n", F_Write);
                }
            }
            else iCondition++;
        }


            fclose(F_Write);
    }

    return 0;
}

int LoadHexAssemblerData(const char * sInput, unsigned char * cPassback, int iLimit)
{

    FILE * FRead;
    bool bWrite = false;
    bool bSkip = false;
    int iValue = 0;
    int iCondition = 0;
    int iFound = 0;
    int iFirst, iSecond;
    int iTrack = 0;
    //int iError = 0;

    FRead = fopen( sInput,"r");

    if (FRead == NULL)
    {
        fclose(FRead);
        return 666;
    }
    else
    {
        while ( iCondition == 0 )
        {
            iValue = getc(FRead);
            iCondition = feof(FRead);
//----------------------------------------------------------------------------------
            if ( iValue == ';' )
            {
                bSkip = true;
                //iError++;
            }

            if ( iValue == 10 ) // should be end of line, this might be different depending on how the text file was generated!
            {
                bSkip=false;
                //iError++;
            }

            if ( iValue >= '0' && iValue <= 'F')
            {
                if ( iValue >= ':' && iValue <= '@')
                {
                    bWrite = false;
                    iTrack = 0;
                }
                else
                {
                    iTrack++;
                    if ( iTrack == 1 )
                    {
                        iFirst = iValue;
                    }

                    if ( iTrack == 2 )
                    {
                        iSecond = iValue;
                        iTrack = 0;
                        bWrite = true;
                    }
                }


            }
            else
            {
                iTrack = 0;
                bWrite = false;
            }
//---------------------------------------------------------------------------------
            if ( iFound < iLimit && iCondition == 0)
            {
                if ( bWrite == true && bSkip == false )
                {
                    *(cPassback + iFound) = ConvertToDecimal(iFirst,iSecond);
                    iFound++;
                    bWrite = false;
                    iTrack = 0;
                }

            }
        }


            fclose(FRead);
    }

    return 0;
}


int SaveHexAssemblerData(const char * sOutput, unsigned char * cPassback, int iLimit)
{

    FILE * F_Write;

    int iCondition = 0;
    int iFound = 0;
    int iEight = 8;

    F_Write = fopen( sOutput,"w"); // do we need to use wb to indicate binary not text mode?

    if (F_Write == NULL)
    {
        //fclose(F_Write);
        return 666;
    }
    else
    {
        fputs("; Assembly language data in Hexadecimal. \n", F_Write);
        fputs("; Generated by Mono8bitmap \n", F_Write);
        while ( iCondition == 0 )
        {

            if ( iFound < iLimit )
            {
                if ( iEight == 8 ) fputs(".byte ", F_Write);
                if ( *(cPassback + iFound) < 16 ) fputs("$0", F_Write); // add a leading zero
                else fputc('$', F_Write);
                fprintf( F_Write, "%X", *(cPassback + iFound));
                iFound++;
                if ( iEight <= 8 && iEight > 1 ) fputc(',', F_Write);
                iEight--;
                if ( iEight < 1)
                {
                    iEight = 8;
                    fputs("\n", F_Write);
                }
            }
            else iCondition++;
        }


            fclose(F_Write);
    }

    return 0;
}
